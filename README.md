<p align="center">
<img width="650" height="200" alt="banner" src="https://github.com/user-attachments/assets/9d1dbefc-b160-448d-8a14-bc26bd2dab8d" />
</p>

### UPDATE: Results!
- The game placed #56 out of 9,599 entries in the Enjoyment category!
- Overall, the game's ratings were beyond what I could have expected
- The game's ratings page is here: [OUROBOROS GMTK Game Jam Page](https://itch.io/jam/gmtk-2025/rate/3766861)
- You can play the game here: [OUROBOROS](https://m4ngodev.itch.io/ouroboros)

### Made for the GMTK Game Jam 2025
- OUROBOROS is a puzzle game I made for the GMTK Game Jam 2025
- The jam's theme was "loop," so I (like many others) decided to make a game about a snake eating its own tail
- The game stretched my level design and game polish abilities a lot!

<p align="center">
<img width="1262" height="691" alt="image" src="https://github.com/user-attachments/assets/2e6c9a89-9198-40a8-a4da-bc50e452059f" />
</p>

### What I learned
- I learned to be extremely economical about my design choices. I originally intended for there to be many mechanics, such as a fruit that decreased the snake's size, pressure plates that required the snake to be a certain length, and whatnot.
- However, for the levels to be polished before the deadline, I realized that I should limit myself to the mechanics that most effectively explored the snake's movement mechanics. As such, I kept four level elements:
  - Apples (which make the snake grow)
  - Walls (which were necessary for creating obstacles in the levels)
  - Portals (which synergized well with the other mechanics)
  - Lanterns (which gave the player a secondary goal beyond eating their own tail)
- I also learned how to conduct playtesting. In order to ensure the game was fun and easily understandable, I called in several friends to playtest my game.
  - After I implemented every new level element, I would add a new batch of levels to the game and have a friend play it.
  - I spectated them playing the game over a screenshare and offered practically zero advice to them, with the goal of seeing how players would interact with the game in the wild.
  - I purposefully chose friends who have different experiences with gaming to get a broader range of feedback.
  - On top of the player's feedback, I would add my own notes of challenges and inaccessibilities I noticed while players were playing.
  - For example, I noticed that one player spent several minutes trying to figure out how the lanterns worked, unaware that they had to occupy the 4 points around the lantern to light it. To easily remedy this, I added little indicators in the level to show which points needed to be occupied.
- Additionally, I learned how to make my game more accessible to players of all skill levels
  - From the playtesting, I noticed that players who were well-versed in puzzle games would breeze through, enjoying the little tricks and red herrings I added to the game. Unfortunately, many playtesters found the game frustrating and unreadable.
  - I refused to add an explicit tutorial to the game, though. So, to bridge the gap in skill levels, I changed most of the level names to be little hints about the level's solution. For skilled players, they could pick up on the hints and feel clever for dissecting the developer's design decisions.
  - For unskilled players, when they began to find the level frustrating, I found that they would re-evaluate the level title, trying to parse the solution from that. Essentially, it gave unskilled players a secondary approach to solving the level, besides brute-forcing the puzzle
- Finally, I learned that keeping my scope small allowed for much more polished, enjoyable products.
  - Because I pruned my mechanics, I finished the levels early and had time for lots of playtesting and polishing.
  - I had time to work on the game's audio, draw thumbnail art, and even make a cool title screen.
  - Having this polish definitely contributed to the game's success, and it also made development a lot more fun!
